<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Détection de Mains - Navigation Interactive</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            overflow: hidden;
            background: #000;
            font-family: Arial, sans-serif;
        }

        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        #mainImage {
            position: absolute;
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
            transition: transform 0.3s ease;
            transform-origin: center center;
        }

        #videoContainer {
            position: fixed;
            top: 10px;
            right: 10px;
            width: 320px;
            height: 240px;
            border: 2px solid #fff;
            border-radius: 8px;
            overflow: hidden;
            background: #000;
            z-index: 1000;
        }

        #webcam {
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
        }

        #canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            transform: scaleX(-1);
        }

        #status {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #fff;
            padding: 15px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 1000;
            max-width: 300px;
        }

        .status-item {
            margin: 5px 0;
        }

        .gesture-active {
            color: #4CAF50;
            font-weight: bold;
        }

        #debugZones {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }

        .debug-zone {
            position: absolute;
            border: 2px dashed rgba(255, 0, 0, 0.5);
            background: rgba(255, 0, 0, 0.1);
            pointer-events: none;
        }

        .loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 24px;
            z-index: 2000;
        }

        #pointer {
            position: fixed;
            width: 30px;
            height: 30px;
            border: 3px solid #00FF00;
            border-radius: 50%;
            background: rgba(0, 255, 0, 0.3);
            pointer-events: none;
            z-index: 500;
            display: none;
            transform: translate(-50%, -50%);
            box-shadow: 0 0 15px rgba(0, 255, 0, 0.8);
        }

        #pointer::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 8px;
            height: 8px;
            background: #00FF00;
            border-radius: 50%;
        }

        #pointer.active {
            border-color: #FF0000;
            background: rgba(255, 0, 0, 0.3);
            box-shadow: 0 0 15px rgba(255, 0, 0, 0.8);
        }

        #pointer.active::after {
            background: #FF0000;
        }
    </style>
</head>
<body>
    <div id="container">
        <img id="mainImage" src="" alt="Image principale">
        <div id="debugZones"></div>
    </div>

    <div id="pointer"></div>

    <div id="videoContainer">
        <video id="webcam" autoplay playsinline></video>
        <canvas id="canvas"></canvas>
    </div>

    <div id="status">
        <div class="status-item">État: <span id="statusText">Initialisation...</span></div>
        <div class="status-item">Image: <span id="currentImage">-</span></div>
        <div class="status-item">Geste: <span id="gestureText">-</span></div>
        <div class="status-item">Zoom: <span id="zoomLevel">1.0x</span></div>
    </div>

    <div class="loading" id="loading">Chargement de MediaPipe...</div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>

    <script>
        // Attendre le chargement complet de MediaPipe
        window.drawConnectors = window.drawConnectors || function() {};
        window.drawLandmarks = window.drawLandmarks || function() {};
        window.HANDS_CONNECTIONS = window.HANDS_CONNECTIONS || [];

        // Configuration et variables globales
        let config = null;
        let currentImageId = 1;
        let currentZoom = 1.0;
        let isZooming = false;
        let lastDistance = 0;
        let baseZoom = 1.0;
        let translateX = 0;
        let translateY = 0;
        let lastCenterX = 0;
        let lastCenterY = 0;
        let lastImageChange = 0;
        let imageChangeDelay = 1000; // 1 seconde de délai entre les changements d'image

        const mainImage = document.getElementById('mainImage');
        const webcam = document.getElementById('webcam');
        const canvasElement = document.getElementById('canvas');
        const canvasCtx = canvasElement.getContext('2d');
        const statusText = document.getElementById('statusText');
        const currentImageText = document.getElementById('currentImage');
        const gestureText = document.getElementById('gestureText');
        const zoomLevelText = document.getElementById('zoomLevel');
        const loading = document.getElementById('loading');
        const pointer = document.getElementById('pointer');

        // Charger la configuration
        async function loadConfig() {
            try {
                const response = await fetch('config.json');
                config = await response.json();
                loadImage(currentImageId);
                statusText.textContent = 'Configuration chargée';
            } catch (error) {
                console.error('Erreur chargement config:', error);
                statusText.textContent = 'Erreur config';
            }
        }

        // Charger une image
        function loadImage(imageId) {
            const now = Date.now();
            // Vérifier le délai anti-rebond
            if (now - lastImageChange < imageChangeDelay) {
                console.log('Changement d\'image trop rapide, ignoré');
                return;
            }
            
            const imageData = config.images.find(img => img.id === imageId);
            if (imageData) {
                mainImage.src = imageData.file;
                currentImageId = imageId;
                currentImageText.textContent = imageData.file;
                currentZoom = 1.0;
                translateX = 0;
                translateY = 0;
                updateZoom();
                drawDebugZones(imageData.zones);
                lastImageChange = now;
                console.log('Image chargée:', imageData.file);
            } else {
                console.error('Image non trouvée pour l\'ID:', imageId);
            }
        }

        // Dessiner les zones de debug
        function drawDebugZones(zones) {
            const debugContainer = document.getElementById('debugZones');
            debugContainer.innerHTML = '';
            
            zones.forEach((zone, index) => {
                const zoneDiv = document.createElement('div');
                zoneDiv.className = 'debug-zone';
                zoneDiv.style.left = zone.pt1.x + 'px';
                zoneDiv.style.top = zone.pt1.y + 'px';
                zoneDiv.style.width = (zone.pt2.x - zone.pt1.x) + 'px';
                zoneDiv.style.height = (zone.pt2.y - zone.pt1.y) + 'px';
                debugContainer.appendChild(zoneDiv);
            });
        }

        // Mettre à jour le zoom et la translation
        function updateZoom() {
            mainImage.style.transform = `translate(${translateX}px, ${translateY}px) scale(${currentZoom})`;
            zoomLevelText.textContent = currentZoom.toFixed(2) + 'x';
        }

        // Mettre à jour la position du pointeur
        function updatePointer(indexLandmark, isPointing) {
            if (indexLandmark) {
                const x = indexLandmark.x * window.innerWidth;
                const y = indexLandmark.y * window.innerHeight;
                
                pointer.style.left = x + 'px';
                pointer.style.top = y + 'px';
                pointer.style.display = 'block';
                
                if (isPointing) {
                    pointer.classList.add('active');
                } else {
                    pointer.classList.remove('active');
                }
            } else {
                pointer.style.display = 'none';
            }
        }

        // Calculer la distance entre deux points
        function calculateDistance(p1, p2) {
            return Math.sqrt(Math.pow(p2.x - p1.x, 2) + Math.pow(p2.y - p1.y, 2));
        }

        // Vérifier si le pouce et l'index se touchent (pour le zoom)
        function isPinching(landmarks) {
            const thumb = landmarks[4];
            const index = landmarks[8];
            const distance = calculateDistance(thumb, index);
            return distance < 0.05; // Seuil de proximité
        }

        // Vérifier si l'index est levé et les autres doigts baissés (pour la sélection)
        function isPointingIndex(landmarks) {
            const indexTip = landmarks[8];
            const indexPip = landmarks[6];
            const middleTip = landmarks[12];
            const middlePip = landmarks[10];
            const ringTip = landmarks[16];
            const ringPip = landmarks[14];
            const pinkyTip = landmarks[20];
            const pinkyPip = landmarks[18];
            const wrist = landmarks[0];
            
            // L'index doit être levé (le bout est plus haut que l'articulation)
            const indexExtended = indexTip.y < indexPip.y;
            
            // Le majeur doit être baissé
            const middleFolded = middleTip.y > middlePip.y;
            
            // L'annulaire doit être baissé
            const ringFolded = ringTip.y > ringPip.y;
            
            // L'auriculaire doit être baissé
            const pinkyFolded = pinkyTip.y > pinkyPip.y;
            
            // L'index doit être significativement plus haut que le poignet
            const indexRaised = (wrist.y - indexTip.y) > 0.1;
            
            return indexExtended && middleFolded && ringFolded && pinkyFolded && indexRaised;
        }

        // Vérifier si un point est dans une zone
        function isInZone(point, zone, imageRect) {
            const x = point.x * imageRect.width + imageRect.left;
            const y = point.y * imageRect.height + imageRect.top;
            
            return x >= zone.pt1.x && x <= zone.pt2.x &&
                   y >= zone.pt1.y && y <= zone.pt2.y;
        }

        // Traiter les résultats de MediaPipe
        function onResults(results) {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            if (results.multiHandLandmarks && results.multiHandedness) {
                const hands = results.multiHandLandmarks;
                const handedness = results.multiHandedness;

                // Dessiner les mains
                for (let i = 0; i < hands.length; i++) {
                    window.drawConnectors(canvasCtx, hands[i], window.HANDS_CONNECTIONS, {color: '#00FF00', lineWidth: 2});
                    window.drawLandmarks(canvasCtx, hands[i], {color: '#FF0000', lineWidth: 1, radius: 3});
                }

                // Détecter les gestes
                if (hands.length === 2) {
                    handleTwoHands(hands, handedness);
                } else if (hands.length === 1) {
                    handleOneHand(hands[0], handedness[0]);
                }
            } else {
                gestureText.textContent = 'Aucune main détectée';
                isZooming = false;
            }

            canvasCtx.restore();
        }

        // Gérer deux mains (zoom + translation)
        function handleTwoHands(hands, handedness) {
            const hand1 = hands[0];
            const hand2 = hands[1];

            const pinch1 = isPinching(hand1);
            const pinch2 = isPinching(hand2);

            if (pinch1 && pinch2) {
                const thumb1 = hand1[4];
                const thumb2 = hand2[4];
                
                // Calculer le centre entre les deux mains
                const centerX = (thumb1.x + thumb2.x) / 2;
                const centerY = (thumb1.y + thumb2.y) / 2;
                
                const distance = calculateDistance(thumb1, thumb2);

                if (!isZooming) {
                    isZooming = true;
                    lastDistance = distance;
                    baseZoom = currentZoom;
                    lastCenterX = centerX;
                    lastCenterY = centerY;
                    gestureText.textContent = 'Mode Zoom + Translation Actif';
                    gestureText.className = 'gesture-active';
                } else {
                    // Calcul du zoom
                    const ratio = distance / lastDistance;
                    currentZoom = Math.max(1.0, Math.min(8.0, baseZoom * ratio));
                    
                    // Calcul de la translation (uniquement si zoomé)
                    if (currentZoom > 1.0) {
                        const deltaX = (centerX - lastCenterX) * window.innerWidth * 2;
                        const deltaY = (centerY - lastCenterY) * window.innerHeight * 2;
                        translateX += deltaX;
                        translateY += deltaY;
                        
                        // Limiter la translation
                        const maxTranslate = 500;
                        translateX = Math.max(-maxTranslate, Math.min(maxTranslate, translateX));
                        translateY = Math.max(-maxTranslate, Math.min(maxTranslate, translateY));
                    } else {
                        // Réinitialiser la translation si zoom = 1
                        translateX = 0;
                        translateY = 0;
                    }
                    
                    lastCenterX = centerX;
                    lastCenterY = centerY;
                    
                    updateZoom();
                    gestureText.textContent = `Zoom: ${currentZoom.toFixed(2)}x | Translation: ${Math.round(translateX)}, ${Math.round(translateY)}`;
                }
                
                // Masquer le pointeur en mode zoom
                pointer.style.display = 'none';
            } else {
                if (isZooming) {
                    isZooming = false;
                    // Réinitialiser la translation si on sort du zoom
                    if (currentZoom === 1.0) {
                        translateX = 0;
                        translateY = 0;
                        updateZoom();
                    }
                    gestureText.textContent = 'Zoom désactivé';
                    gestureText.className = '';
                }
            }
        }

        // Gérer une main (sélection de zone + pointeur)
        function handleOneHand(hand, handInfo) {
            if (isZooming) {
                pointer.style.display = 'none';
                return;
            }

            const isPointing = isPointingIndex(hand);
            const index = hand[8]; // Index finger tip
            
            // Identifier la main droite
            const isRightHand = handInfo.label === 'Right';
            
            // Afficher le pointeur uniquement pour la main droite
            if (isRightHand) {
                updatePointer(index, isPointing);
            } else {
                pointer.style.display = 'none';
            }

            if (isPointing && isRightHand) {
                const imageRect = mainImage.getBoundingClientRect();
                const imageData = config.images.find(img => img.id === currentImageId);

                if (imageData) {
                    // Convertir la position de l'index en coordonnées d'écran
                    const screenX = index.x * window.innerWidth;
                    const screenY = index.y * window.innerHeight;
                    
                    // Vérifier si le pointeur est dans une zone
                    for (let zone of imageData.zones) {
                        if (screenX >= zone.pt1.x && screenX <= zone.pt2.x &&
                            screenY >= zone.pt1.y && screenY <= zone.pt2.y) {
                            
                            gestureText.textContent = `Zone détectée → ${zone.targetImage}`;
                            gestureText.className = 'gesture-active';
                            
                            // Trouver l'image cible par nom de fichier
                            const targetImageData = config.images.find(img => img.file === zone.targetImage);
                            if (targetImageData) {
                                // Charger uniquement si ce n'est pas déjà l'image actuelle
                                if (targetImageData.id !== currentImageId) {
                                    loadImage(targetImageData.id);
                                }
                            } else {
                                // Si l'image cible n'existe pas dans la config, essayer de la charger directement
                                console.log('Image non trouvée dans config, tentative de chargement direct:', zone.targetImage);
                                mainImage.src = zone.targetImage;
                                currentImageText.textContent = zone.targetImage;
                            }
                            return;
                        }
                    }
                    gestureText.textContent = 'Index levé (hors zone)';
                }
            } else {
                if (isRightHand) {
                    gestureText.textContent = 'Main droite détectée';
                } else {
                    gestureText.textContent = 'Main gauche détectée';
                }
                gestureText.className = '';
            }
        }

        // Initialiser MediaPipe Hands
        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });

        hands.setOptions({
            selfieMode: true,
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        // Initialiser la caméra
        async function initCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { 
                        width: { ideal: 640 },
                        height: { ideal: 480 },
                        facingMode: 'user'
                    }
                });
                webcam.srcObject = stream;

                await new Promise((resolve) => {
                    webcam.onloadedmetadata = () => {
                        canvasElement.width = webcam.videoWidth;
                        canvasElement.height = webcam.videoHeight;
                        resolve();
                    };
                });

                // Démarrer le traitement vidéo
                processVideo();
                
                loading.style.display = 'none';
                statusText.textContent = 'Système actif';
            } catch (error) {
                console.error('Erreur caméra:', error);
                statusText.textContent = 'Erreur caméra: ' + error.message;
                loading.textContent = 'Erreur: Caméra non accessible';
            }
        }

        // Traitement vidéo frame par frame
        async function processVideo() {
            async function sendFrame() {
                if (webcam.readyState === webcam.HAVE_ENOUGH_DATA) {
                    await hands.send({ image: webcam });
                }
                requestAnimationFrame(sendFrame);
            }
            sendFrame();
        }

        // Démarrage de l'application
        async function init() {
            await loadConfig();
            await initCamera();
        }

        // Lancer l'application
        init();
    </script>
</body>
</html>
